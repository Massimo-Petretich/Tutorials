---
author: "Massimo Petretich"
date: "November 2015"
title: "Identification of chromatin states using Hidden Markov Models"
output:
  html_document:
    toc: true
    number_sections: true
---

# Introduction

Hidden Markov Models are used whenever there is the need to classify raw observations.These models have found multiple applications in biology. Here we propose an implementation of such models to classify different "chromatin states" or in other words, regions of the chromosome characterized by the presence of specific histone modifications. Hidden Markov Models are based on 2 stochastic processes a visible one and an invisible one. The visible process is represented by the observations while the invisible one constitutes the Markov Chain. The Markov Chain is a model that describes a sequence of different states (the categories in the model). In this model, the probability of transition from a state to another depends uniquely on the current state. These transition probabilities are summarized as a matrix (transition matrix).

# ChIP coverage files loading and processing
```{r, eval=FALSE}
library(RHmm) # As of 2020, no longer in CRAN, https://r-forge.r-project.org/R/?group_id=85
library(rtracklayer)
library(MPgraphics)
```

## Files import
The ChIP-seq datasets were obtained from facial mesenchyme of stage E11.5 mouse embryos. Some of the datasets can be retrieved using the SRA ID specified on the paper: https://pubmed.ncbi.nlm.nih.gov/24859337/
```{r, eval=FALSE}
parameters <- list(cores = 12, binSize = 5000, window = 200000, wd = getwd())

files <- list(
  H3K27me3 = "Face-H3K27me3_ratio.bw", 
	H3K27ac = "Face-H3K27ac_ratio.bw", 
	H3K4me1 = "Face-H3K4me1_ratio.bw", 
	H2AZ = "Face-H2AZ_ratio.bw", 
	H3K9me3 = "Face-H3K9me3_ratio.bw"
	)

# load the coverage tracks
tracks <- mclapply(files, import.bw, as = "RleList", mc.cores = parameters$cores)
```

## Check if all the chromosomes are long enough
```{r, eval=FALSE}
tracks <- lapply(
	  tracks, 
	  function(track) track[vapply(track, function(x) length(x) >= 10 * parameters$window, logical(1))]
	  )
```

## Create a new generic "hmmFitToRle"
```{r, eval=FALSE}
hmmFitToRle <- function(coverage, nStates = 2L, control = list(tol = 1e-6), bins = 5000, name = "chr", RleList = FALSE, verbose = FALSE) UseMethod("hmmFitToRle")
```



# Univariate segmentation
The section below introduces the parameters used for the HMM fitting. The moving window used to smooth the coverage tracks may look very large (200kbp), however the purpose of this segmentation is to identify large blocks showing enrichment of particular histone modifications. With the low coverage of most ChIP-seq experimemts, if no smoothing is applied HMMs tend to segment the nucleosome positioning, or, the biases due to sonication on the low kbp scale (a possible excersise could be to tweek these parameters and see at what level this effects starts).
Similarly to what mentioned above, the reason why the bin sizes are 5kb is because the scope of this analysis is not to identify the regions enriched for histone modifications with high resolution, but rather to focus on a larger, subchromosomal scale. Also, a factor 10 less bins makes the computations much faster.
```{r, eval=FALSE}
parameters <- list(cores = 12L, binSize = 5000L, window = 200000L, nStates = 2L)
```

## Condense the coverage tracks into bins and smooth them
```{r, eval=FALSE}
# list -> list -> numeric

tracksSmoothedBinned <- lapply(
  tracks, 
  function(track) {
    mclapply(
      X = track, 
      FUN = smoothRle, # from the MPgraphic package, just a running window function in this case performing a smoothing
      resolution = parameters$binSize, # smoothRle does also a binning of the genome in predefined bin sizes 
      vector = TRUE, 
      smooth = TRUE, 
      window = parameters$window, 
      mc.cores = parameters$cores
      )
    }
  ) 
```

## Fit univariate HMM
```{r, eval=FALSE}
# list(track) -> RleList

hmmFitToRle.numeric <- function(coverage, nStates = 2L, control = list(tol = 1e-6), bins = 5000, name = "chr", RleList = FALSE, verbose = FALSE) {
	coverageSplit <- split(coverage, ceiling(seq_along(coverage)/40000))
	hmmFit <- HMMFit(coverage, nStates = nStates, control = control)
	vitPath <- lapply(coverageSplit, function(x) viterbi(hmmFit, x)$states)
	vitPath <- unlist(Reduce("c", vitPath))
	vitPath <- Rle(values = vitPath, lengths = rep(bins, length(coverage)))
	if (RleList) {vitPath <- RleList(vitPath); names(vitPath) <- name}
	if (verbose) print(list(vitPath, hmmFit))
	return(vitPath)
}

tracksHMM <- lapply( # loop 1: over coverage vectors 
  tracksSmoothedBinned, 
  function (track) {
    x <- mclapply( # loop 2 over chromosomes of a given track (makes better use of the multithreading here, loop 1 has just e objects)
      track, 
      hmmFitToRle, # actual Hidden-Markov-Model
      nStates = parameters$nStates, # Since there is just one track, it makes sense to have just 2 states: enriched and non-enriched
      control = list(tol = 1e-9), 
      bins = parameters$binSize, 
      verbose = 1, 
      name = "chr", 
      RleList = FALSE, 
      mc.cores = parameters$cores
      )
    names(x) <- names(track)
    x <- RleList(x, compress = FALSE)
    return(x)
    }
  )
```

## Export .bw HMMtracks
```{r, eval=FALSE}
mcmapply(
  function(RleList, dirname, basename) export.bw(RleList, paste0(file.path(dirname, basename), "_segmented.bw")), 
  RleList = tracksHMM, 
  dirname = sapply(files, dirname), 
  basename = names(files), 
  mc.cores = parameters$cores
  )

```



# Multivariate segmentation
```{r, eval=FALSE}
parameters <- list(cores = 12L, binSize = 2000L, window = 50000L, nStates = 5L)
```

## Condense the coverage tracks into bins and smooth them
```{r, eval=FALSE}
# list -> list -> numeric

tracksSmoothedBinned <- lapply(
  X = tracks, 
  FUN = function(track) {
    mclapply(
      track, 
      smoothRle, 
      resolution = parameters$binSize, 
      vector = TRUE, 
      smooth = TRUE, 
      window = parameters$window, 
      mc.cores = parameters$cores
      )
    }
  ) 
```

## Trim all the chromosomes to the same length
This step is done in order to be able to construct a matrix the following section. This may happen for example when the reads reach different positions at the end of a chromosome in different datasets. 
```{r, eval=FALSE}
# list(track) -> list(chr) -> numeric

chrDimensions <- apply(
  sapply(tracksSmoothedBinned, function(x) sapply(x, length)), 
  max, 
  MARGIN=1
  )

tracksSmoothedBinned <- lapply(
  tracksSmoothedBinned, 
  function (track, chrDimensions) mapply(
    function(trackChr, chrDimension) trackChr[1:chrDimension], 
    trackChr = track, 
    chrDimension = chrDimensions
    ), 
  chrDimensions = chrDimensions
  )
```

## Reorganize the dataset by chromosomes instead of by tracks
```{r, eval=FALSE}
# list(chr)->matrix(rows=tracks, cols=coordinates)

tracksSmoothedBinned_unlisted <- unlist(tracksSmoothedBinned, recursive = FALSE)
	
tracksSmoothedBinned_byChr <- split(
  tracksSmoothedBinned_unlisted, 
  as.factor(vapply(strsplit(names(tracksSmoothedBinned_unlisted), "\\."), `[`, i = 2, character(1)))
  )
	
rm(list = c("tracksSmoothedBinned_unlisted", "chrDimensions"))
```

## Rename the rows (names combined after unlisting) and transpose
```{r, eval=FALSE}
# list(chr) -> matrix(cols=tracks, rows=coordinates)

tracksSmoothedBinned_byChr <- lapply(
  tracksSmoothedBinned_byChr, 
  function (x) {
    x <- do.call("rbind", x)
    row.names(x) <- vapply(strsplit(row.names(x), "\\."), `[`, i = 1, character(1))
    x <- t(x)
    return(x)
    }
  )

pdf(file.path(getwd(), "distributions.pdf"))
  apply(tracksSmoothedBinned_byChr[[1]], function(x) hist(x, breaks=80), MARGIN=2)
dev.off()
```

## Filter out uninformative chromosomes
```{r, eval=FALSE}
tracksSmoothedBinned_byChr <- tracksSmoothedBinned_byChr[sapply(tracksSmoothedBinned_byChr, function(tracksSmoothedBinned_byChr) ! any(apply(tracksSmoothedBinned_byChr, function(x) all(x == 0), MARGIN=2)))]
```


## Robust (outliers-insensitive) standardization
```{r, eval=FALSE}
tracksSmoothedBinned_byChr <- mclapply(
  X = tracksSmoothedBinned_byChr, 
  FUN = function(tracksSmoothedBinned_byChr) apply(
    tracksSmoothedBinned_byChr, 
    function(x) (x - mean(x)) / mad(x), MARGIN = 2
    ), 
  mc.cores = parameters$cores
  )
	
# Same thing but with the function 'smhuber' replacing the 'mean'
# library(smoothmest)

# tracksSmoothedBinned_byChr <- mclapply(
#   tracksSmoothedBinned_byChr, 
#   function(tracksSmoothedBinned_byChr) apply(
#     tracksSmoothedBinned_byChr, function(x) (
#       x - smoothmest::smhuber(x)$mu) / mad(x), MARGIN = 2
#     ), 
#   mc.cores = parameters$cores
#   )

pdf(file.path(getwd(), "distributions_2.pdf"))
  apply(tracksSmoothedBinned_byChr[[1]], function(x) hist(x, breaks=80), MARGIN=2)
dev.off()
```

## Fit multivariate HMM
```{r, eval=FALSE}
hmmFitToRle.matrix <- function(coverage, nStates = 2L, control = list(tol = 1e-6), bins = 5000, name = "chr", RleList = FALSE, verbose = FALSE) {
	coverageSplit <- split.data.frame(coverage, ceiling(seq_len(dim(coverage)[1])/40000))
	hmmFit <- try( HMMFit(coverage, nStates = nStates, control = control) )
	if (inherits(hmmFit, "try-error")) return(NA)
	vitPath <- lapply(coverageSplit, function(x) viterbi(hmmFit, x)$states)
	vitPath <- unlist(Reduce("c", vitPath))
	vitPath <- Rle(values = vitPath, lengths = rep(bins, dim(coverage)[1]))
	if (RleList) {vitPath <- RleList(vitPath); names(vitPath) <- name}
	if (verbose) print(list(vitPath, hmmFit))
	return(vitPath)
}

HMMmultivariate <- RleList(
  mclapply(
    X = tracksSmoothedBinned_byChr, 
    FUN = hmmFitToRle, 
    nStates = parameters$nStates, 
    bins = parameters$binSize, 
    verbose = 1, 
    mc.cores = parameters$cores
    ), 
  compress = FALSE
  )
	
HMMmultivariate  <- HMMmultivariate[!any(is.na(HMMmultivariate))]

export.bw(HMMmultivariate, file.path(getwd(), "multivariate3.bw")) 
```


## Create ranges of the HMMstates
```{r, eval=FALSE}
# list(chr)->list(score)->GRanges
HMMmultivariateGR <- as(HMMmultivariate, "GRanges")
HMMmultivariateGR <- split(HMMmultivariateGR, seqnames(HMMmultivariateGR))
HMMmultivariateGR <- lapply(HMMmultivariateGR, `[`, i = -1)

HMMmultivariateGR <- mcmapply(
  split, 
  x = HMMmultivariateGR, 
  f = lapply(HMMmultivariateGR, function (x) as.factor(x$score)), 
  mc.cores = parameters$cores
  )
```

## Extract the Rle corresponding to each range
```{r, eval=FALSE}
# list(track)->list(chr)->list(HMMstate)->Rle
rangesTrack <- lapply(
  tracks, 
  function(HMMmultivariateGR, track) mclapply(
    X = HMMmultivariateGR, 
    FUN = function (HMMmultivariateGR, track) lapply(HMMmultivariateGR, `[`, x = track), 
    track = track, 
    mc.cores = parameters$cores
    ), 
  HMMmultivariateGR = HMMmultivariateGR
  )
```

## Calculate average coverage per Rle
```{r, eval=FALSE}
# list(track)->list(chr)->list(HMMstate)->constant(numeric)
coverageValuesByHMM <- lapply(
  rangesTrack, 
  function(rangesTrack) mclapply(
    rangesTrack, 
    function(rangesTrack) lapply(
      rangesTrack, 
      function (rangesTrack) vapply(
        rangesTrack, 
        FUN = function(rle) sum(rle)/length(rle), 
        FUN.VALUE = numeric(1)
        )
      ), 
    mc.cores = parameters$cores
    )
  )
```

## Construct the final data.frame
```{r, eval=FALSE}
#data.frame("track", "chr", "HMMstate", "Log_Ratio_IP_IN")
coverageValuesByHMM_DF <- unlist(coverageValuesByHMM)
coverageValuesByHMM_DF <- data.frame(tag = names(coverageValuesByHMM_DF), value = coverageValuesByHMM_DF, stringsAsFactors = FALSE)

coverageValuesByHMM_DF <- cbind(
  as.data.frame(
    t(
      sapply(
        coverageValuesByHMM_DF$tag, 
        function(tag) x <- unlist(strsplit(tag, "\\."))[1:3]
        )
      ), 
    stringsAsFactors = FALSE, 
    row.names = 	seq_len(nrow(coverageValuesByHMM_DF))
    ), 
  coverageValuesByHMM_DF[-1]
  )

names(coverageValuesByHMM_DF) <- c("track","chr","HMMstate","Log_Ratio_IP_IN")
```

## Final stats
```{r, eval=FALSE}
library(ggplot2)

pdfBoxplot <- function(data, chr, HMMstate, openConnection = TRUE, file = file.path(getwd(), paste(chr, HMMstate, "HMM.pdf", sep = "_"))) {
	print(match.call())
		localenv <- environment()
		ylim <- c(quantile(data$Log_Ratio_IP_IN, 0.001), quantile(data$Log_Ratio_IP_IN, 0.999))
		p <- ggplot(data = data[grepl(HMMstate, data$HMMstate) & grepl(chr, data$chr), ], aes(factor(track), Log_Ratio_IP_IN), environment = localenv)
		p + 
		geom_boxplot(outlier.size = 0) + 
		ylim(ylim) + 
		labs(title = paste(chr, "HMM state: ", ifelse(HMMstate != "", HMMstate, "all"), sep = " ")) + 
		theme(axis.title.x = element_blank(), axis.text.x = element_text(angle = 90, vjust = 0.5))
	if (openConnection) ggsave (filename = file, width = 3, height = 7)
}

lapply(
  levels(as.factor(coverageValuesByHMM_DF$chr)), 
  function(chr) lapply(
    c(levels(as.factor(coverageValuesByHMM_DF$HMMstate)), ""), 
    function(chr, HMMstate) pdfBoxplot(data = coverageValuesByHMM_DF, 
                                       chr = chr, 
                                       HMMstate = HMMstate
                                       ), 
    chr = chr
    )
  )
```


<img src="C:/Users/mp674001/OneDrive - GSK/Desktop/HMM/HMM_states.jpg" height="300" />

In this panel (showing just the segmented regions on the chromosome 2), we can see different states with different patterns of chromatin marks, for example, the state 1 is compatible with a repressive state, state 2 with an enhancer state and so on. Remarkably, in this study we lack H3K4me3, namely the chosen marker of active promoters, as well as a few other very informative ones such as H3K36me3/PolII and HP1. Possibly, this kind of analysis would have been enhanced by the presence of these additional ChIP datasets.

